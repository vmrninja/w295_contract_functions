// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;

// Contract generated by The Smart Blocks (TM) www.thesmartblocks.com for client #1
// Options:
// Contract Type: Escrow
// Owner Role: Buyer
// Contract Parties: Limited to 1 Seller and 1 Buyer
// Arbitrator: Yes
// Privilege to add parties: Owner only
// Parties who can retract: Buyer Only
// Criteria to retract: 30 days elapsed time (will use 30secs for demo purposes)
// Criteria for sellers pay: Arbitrator ok
// Criteria to auto-cancel: 60 days elapsed time (will use 60secs for demo purposes)

contract Escrow_client_1 {
    struct Sellers_table {
        uint amount;
        bool criteriaMet;
        bool buyerRetract;
        bool paid;
    }

    mapping(address => Sellers_table) public sellers;
    address public buyer;
    address public arbitrator;
    bool arbitratorAdded = false;
    uint autoCancelMet;
    uint sellerCount = 0;
    address sellerID;

// Owner Role: Buyer
// Criteria to auto-cancel: 60 days elapsed time (will use 60secs for demo purposes)

    constructor() {
        buyer = msg.sender;
        autoCancelMet = block.timestamp + 60;
    }

// Contract Parties: Limited to 1 Seller and 1 Buyer
// Privilege to add parties: Owner only

    function addSeller(address seller) external payable {
        require(sellerCount == 0, '** No more Sellers can be added to this contract **');
        require(msg.sender == buyer, '** Only buyer can add Sellers **');
        require(sellers[msg.sender].amount == 0, '** Seller already exists **');
        require(msg.value > 0, '** Offer price must be above zero **');
        sellerCount = 1;
        sellerID = seller;
        sellers[seller] = Sellers_table(msg.value, false, false, false);
    }

// Arbitrator: Yes

    function addArbitrator(address arbitratorInput) external {
        require(msg.sender == buyer, '** Only buyer can add Arbitrator **');
        require(arbitratorAdded == false, '** Arbitrator has already been added **');
        arbitratorAdded = true;
        arbitrator = arbitratorInput;
    }

// Parties who can retract: Buyer Only
// Criteria to retract: 30 days ellapsed time (will use 30secs for demo purposes)

    function buyerRetract(address sellerOffered) external {
        Sellers_table storage seller = sellers[sellerOffered];
        require(seller.paid == false, '** Seller has already been paid **');
        require(msg.sender == buyer, '** Only buyer can retract from this contract **');
        seller.paid = false;
        payable(buyer).transfer(seller.amount);
    }

// Criteria for sellers pay: Arbitrator ok

    function arbitratorOk(address sellerOked) external {
        Sellers_table storage seller = sellers[sellerOked];
        require(arbitratorAdded == true, '** Arbitrator has not been added to this contract **');
        require(msg.sender == arbitrator, '** Only Arbitrator can Ok Seller pay **');
        require(sellers[sellerOked].amount != 0, '** Seller does not exist **');
        seller.criteriaMet = true;
    }

// Seller claim payment clause

    function paySeller() external {
        Sellers_table storage seller = sellers[msg.sender];
        require(seller.criteriaMet == true, '** Criteria for Seller payment not met **');
        require(seller.amount > 0, '** Only the actual Seller can be paid **');
        require(seller.paid == false, '** Seller has already been paid');
        seller.paid = true;
        payable(msg.sender).transfer(seller.amount);
    }

// Auto-cancellation clause

    function autoCancel() external {
        Sellers_table storage seller = sellers[sellerID];
        require(sellerCount == 1, '** No value exist in this contract **');
        require(seller.paid == false, '** Seller has already been paid **');
        require(autoCancelMet <= block.timestamp, '** Contract has not met auto-cancellation criteria **');
        seller.paid = false;
        payable(buyer).transfer(seller.amount);
    }
}
